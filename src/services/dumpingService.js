/**
 * Service for managing illegal dumping reports and history
 */

import supabase from '../utils/supabaseClient.js';
import { toastService } from '../services/toastService.js';

/**
 * Maps the estimated_volume value from the form to the required size value for the database
 * @param {string} estimatedVolume - Value from the form's estimated_volume field
 * @returns {string} Size value for database (small, medium, or large)
 */
const mapEstimatedVolumeToSize = (estimatedVolume) => {
  // Default to 'medium' if no valid value provided
  if (!estimatedVolume) return 'medium';
  
  // Map the form values to database size categories
  const estimatedVolumeLower = estimatedVolume.toLowerCase();
  
  if (estimatedVolumeLower.includes('small') || estimatedVolumeLower.includes('few bags')) {
    return 'small';
  } else if (estimatedVolumeLower.includes('large') || estimatedVolumeLower.includes('truck')) {
    return 'large';
  } else {
    // For everything else (medium size, unknown, etc.), use 'medium'
    return 'medium';
  }
};

export const dumpingService = {
  /**
   * Create a new illegal dumping report
   * @param {string} userId - User ID reporting the dumping
   * @param {Object} reportData - Report details
   * @returns {Object} Created report
   */
  async createReport(userId, reportData) {
    const validatePhotoUrls = (urls) => {
      if (!Array.isArray(urls)) return false;
      return urls.every(url => {
        try {
          new URL(url);
          return true;
        } catch {
          return false;
        }
      });
    };

    const validateEnumValue = (value, allowedValues) => {
      return allowedValues.includes(value);
    };

    try {
      if (!userId) {
        throw new Error('User ID is required');
      }
      
      console.log('[DumpingService] Creating dumping report for user:', userId);

      // Validate required coordinates - handle both direct lat/lng and GeoJSON Point format
      let latitude, longitude;
      if (reportData.coordinates) {
        if (reportData.coordinates.type === 'Point' && Array.isArray(reportData.coordinates.coordinates)) {
          // GeoJSON Point format: {type: 'Point', coordinates: [longitude, latitude]}
          [longitude, latitude] = reportData.coordinates.coordinates;
          console.log('[DumpingService] Found GeoJSON Point coordinates:', { longitude, latitude });
        } else if (typeof reportData.coordinates.latitude === 'number' && typeof reportData.coordinates.longitude === 'number') {
          // Direct lat/lng object: {latitude: number, longitude: number}
          latitude = reportData.coordinates.latitude;
          longitude = reportData.coordinates.longitude;
          console.log('[DumpingService] Found direct lat/lng coordinates:', { latitude, longitude });
        }
      }

      if (typeof latitude !== 'number' || typeof longitude !== 'number') {
        console.error('[DumpingService] Missing or invalid coordinates:', reportData.coordinates);
        throw new Error('Coordinates (latitude and longitude) are required');
      }
      
      // Log the coordinates for debugging
      console.log('[DumpingService] Using coordinates:', { latitude, longitude });

      // Validate severity
      if (reportData.severity && !validateEnumValue(reportData.severity, ['low', 'medium', 'high'])) {
        throw new Error('Invalid severity value. Must be one of: low, medium, high');
      }

      // Validate size
      if (reportData.size && !validateEnumValue(reportData.size, ['small', 'medium', 'large'])) {
        throw new Error('Invalid size value. Must be one of: small, medium, large');
      }

      // Validate photos if provided
      if (reportData.photos && !validatePhotoUrls(reportData.photos)) {
        throw new Error('Invalid photo URL format. All photos must be valid URLs');
      }

      // Convert coordinates to PostGIS/GeoJSON Point format
      // This is the format required by the database schema
      const geoJsonPoint = {
        type: 'Point',
        coordinates: [longitude, latitude]
      };

      console.log('[DumpingService] Formatted GeoJSON Point:', geoJsonPoint);
      
      // Include all required fields for illegal_dumping_mobile table based on confirmed schema
      const report = {
        reported_by: userId,
        location: reportData.location || 'Unknown location',
        coordinates: geoJsonPoint, // PostGIS column expects GeoJSON format
        waste_type: reportData.waste_type || 'mixed',
        severity: reportData.severity || 'medium',
        size: mapEstimatedVolumeToSize(reportData.estimated_volume),
        photos: reportData.photos || [],
        status: 'pending'
        // Note: created_at and updated_at are auto-generated by DB
      };
      
      console.log('[DumpingService] Mapped size value:', report.size);

      // First create the main report in the illegal_dumping_mobile table
      const { data: dumpingReport, error: reportError } = await supabase
        .from('illegal_dumping_mobile')
        .insert(report)
        .select()
        .single();

      if (reportError) {
        console.error('[DumpingService] Error creating dumping report:', reportError);
        console.error('[DumpingService] Report data being inserted:', report);
        console.error('[DumpingService] Error details:', {
          message: reportError.message,
          code: reportError.code,
          details: reportError.details,
          hint: reportError.hint
        });
        // Provide more specific error messages for common issues
        if (reportError.message && reportError.message.includes('column')) {
          throw new Error(`Database schema error: ${reportError.message}`);
        }
        throw new Error(reportError.message || 'Failed to create report in database');
      }

      // Try to create the additional report details in the dumping_reports_mobile table
      try {
        const reportDetails = {
          dumping_id: dumpingReport.id,
          estimated_volume: reportData.estimated_volume || 'unknown',
          hazardous_materials: reportData.hazardous_materials || false,
          accessibility_notes: reportData.description || reportData.accessibility_notes || 'No additional details provided'
          // Note: created_at is auto-generated by DB
        };

        console.log('[DumpingService] Creating dumping report details:', reportDetails);

        const { error: detailsError } = await supabase
          .from('dumping_reports_mobile')
          .insert(reportDetails);

        if (detailsError) {
          console.warn('[DumpingService] Could not create report details entry, but main report created:', detailsError);
          // Don't throw, just log as this is a secondary step
        } else {
          console.log('[DumpingService] Successfully created report details');
        }
      } catch (detailsErr) {
        console.warn('[DumpingService] Report details creation failed, continuing without it:', detailsErr);
      }

      console.log('[DumpingService] Successfully created dumping report:', dumpingReport.id);
      return { data: dumpingReport, error: null };

    } catch (error) {
      console.error('[DumpingService] Error in createReport:', error);
      return {
        data: null,
        error: {
          message: error.message || 'Failed to create dumping report',
          code: error.code || 'CREATE_REPORT_ERROR'
        }
      };
    }
  },

  /**
   * Get report details including history
   * @param {string} reportId - Report ID
   * @returns {Object} Report details with history
   */
  async getReportDetails(reportId) {
    try {
      if (!reportId) {
        throw new Error('Report ID is required');
      }

      console.log('[DumpingService] Fetching report details:', reportId);

      const { data: report, error: reportError } = await supabase
        .from('illegal_dumping_mobile')
        .select(`
          *,
          dumping_reports (*),
          illegal_dumping_history (*)
        `)
        .eq('id', reportId)
        .single();

      if (reportError) {
        console.error('[DumpingService] Error fetching report details:', reportError);
        throw reportError;
      }

      return { data: report, error: null };

    } catch (error) {
      console.error('[DumpingService] Error in getReportDetails:', error);
      return {
        data: null,
        error: {
          message: error.message || 'Failed to fetch report details',
          code: error.code || 'GET_REPORT_ERROR'
        }
      };
    }
  },

  /**
   * Update report status
   * @param {string} reportId - Report ID
   * @param {string} status - New status
   * @param {string} userId - User ID making the update
   * @param {string} notes - Optional notes about the update
   * @returns {Object} Updated report
   */
  async updateReportStatus(reportId, status, userId, notes = '') {
    // Validate status
    const validStatuses = ['pending', 'verified', 'in_progress', 'completed'];
    if (!validStatuses.includes(status)) {
      return {
        data: null,
        error: {
          message: `Invalid status value. Must be one of: ${validStatuses.join(', ')}`,
          code: 'INVALID_STATUS'
        }
      };
    }

    try {
      if (!reportId || !status || !userId) {
        throw new Error('Report ID, status, and user ID are required');
      }

      console.log('[DumpingService] Updating report status:', reportId, status);

      // Update the main report
      const { data: report, error: reportError } = await supabase
        .from('illegal_dumping_mobile')
        .update({
          status,
          updated_at: new Date().toISOString()
        })
        .eq('id', reportId)
        .select()
        .single();

      if (reportError) {
        console.error('[DumpingService] Error updating report status:', reportError);
        throw reportError;
      }

      // Add history entry
      const historyEntry = {
        dumping_id: reportId,
        status,
        notes: notes || `Status updated to ${status}`,
        updated_by: userId,
        created_at: new Date().toISOString()
      };

      const { error: historyError } = await supabase
        .from('illegal_dumping_history_mobile')
        .insert(historyEntry);

      if (historyError) {
        console.error('[DumpingService] Error creating history entry:', historyError);
        throw historyError;
      }

      console.log('[DumpingService] Successfully updated report status');
      return { data: report, error: null };

    } catch (error) {
      console.error('[DumpingService] Error in updateReportStatus:', error);
      return {
        data: null,
        error: {
          message: error.message || 'Failed to update report status',
          code: error.code || 'UPDATE_STATUS_ERROR'
        }
      };
    }
  },

  /**
   * Get nearby dumping reports
   * @param {Object} location - Location to search around {latitude, longitude}
   * @param {number} radiusKm - Search radius in kilometers
   * @returns {Array} Array of nearby reports
   */
  async getNearbyReports(location, radiusKm = 5) {
    try {
      if (!location?.latitude || !location?.longitude) {
        throw new Error('Valid location is required');
      }

      console.log('[DumpingService] Finding reports near:', location);

      // Use PostGIS to find nearby reports
      const { data, error } = await supabase.rpc('find_nearby_dumping', {
        p_latitude: location.latitude,
        p_longitude: location.longitude,
        p_radius_km: radiusKm
      });

      if (error) {
        console.error('[DumpingService] Error finding nearby reports:', error);
        throw error;
      }

      return { data: data || [], error: null };

    } catch (error) {
      console.error('[DumpingService] Error in getNearbyReports:', error);
      return {
        data: [],
        error: {
          message: error.message || 'Failed to find nearby reports',
          code: error.code || 'NEARBY_REPORTS_ERROR'
        }
      };
    }
  },

  /**
   * Add photos to an existing report
   * @param {string} reportId - Report ID
   * @param {string[]} photoUrls - Array of photo URLs
   * @param {string} userId - User ID adding the photos
   * @returns {Object} Updated report
   */
  async addPhotosToReport(reportId, photoUrls, userId) {
    const validatePhotoUrls = (urls) => {
      if (!Array.isArray(urls)) return false;
      return urls.every(url => {
        try {
          new URL(url);
          return true;
        } catch {
          return false;
        }
      });
    };

    try {
      if (!reportId || !photoUrls?.length || !userId) {
        throw new Error('Report ID, photos, and user ID are required');
      }

      console.log('[DumpingService] Adding photos to report:', reportId);

      // Get current photos
      const { data: currentReport } = await supabase
        .from('illegal_dumping_mobile')
        .select('photos')
        .eq('id', reportId)
        .single();

      const updatedPhotos = [...(currentReport?.photos || []), ...photoUrls];

      // Update the report with new photos
      const { data: report, error: reportError } = await supabase
        .from('illegal_dumping_mobile')
        .update({
          photos: updatedPhotos,
          updated_at: new Date().toISOString()
        })
        .eq('id', reportId)
        .select()
        .single();

      if (reportError) {
        console.error('[DumpingService] Error updating report photos:', reportError);
        throw reportError;
      }

      // We don't need to add history entry for photos since the photos field doesn't exist in either table
      // based on the confirmed database schema

      console.log('[DumpingService] Successfully added photos to report');
      return { data: report, error: null };

    } catch (error) {
      console.error('[DumpingService] Error in addPhotosToReport:', error);
      return {
        data: null,
        error: {
          message: error.message || 'Failed to add photos to report',
          code: error.code || 'ADD_PHOTOS_ERROR'
        }
      };
    }
  }
};

export default dumpingService;
